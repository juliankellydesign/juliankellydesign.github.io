<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <meta name="theme-color" content="#302a25" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#f7f6f2" media="(prefers-color-scheme: light)">
  <title>Asterism</title>
  <meta name="description" content="Generative asterism animation - clusters of glowing dots pulsing in concentric rings">
  <style>
    :root { --bg: oklch(0.194 0.006 55.987); --fg: oklch(1 0 0); --accent: oklch(0.7 0.337 28); }
    @media (prefers-color-scheme: light) { :root { --bg: oklch(0.970 0.003 106.449); --fg: oklch(0 0 0); --accent: oklch(0.7 0.307 78); } }
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: var(--bg); font-family: ui-monospace, 'SF Mono', 'Cascadia Mono', 'Segoe UI Mono', Menlo, Monaco, Consolas, monospace; transition: background 0.4s; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; user-select: none; background: var(--bg); transition: background 0.4s; }
    @media (max-width: 599px) { canvas { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); } }
    #controls-wrap { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
    #toggle-btn {
      pointer-events: auto; margin-bottom: 8px; padding: 8px 20px; border-radius: 9999px;
      font-size: 12px; font-family: inherit; cursor: pointer; user-select: none;
      background: color-mix(in oklch, var(--fg), transparent 95%);
      color: color-mix(in oklch, var(--fg), transparent 65%);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border: 1px solid color-mix(in oklch, var(--fg), transparent 94%);
      min-height: 44px; min-width: 44px; transition: opacity 0.15s, background 0.4s, color 0.4s, border-color 0.4s;
    }
    #toggle-btn:hover { opacity: 0.8; }
    #panel {
      display: none; pointer-events: auto; width: 100%; max-width: 28rem;
      padding: 16px 20px 32px; flex-direction: column; gap: 4px;
      background: color-mix(in oklch, var(--bg), transparent 12%);
      backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
      border-top: 1px solid color-mix(in oklch, var(--fg), transparent 95%);
      transition: background 0.4s, border-color 0.4s;
    }
    #panel.open { display: flex; }
    .slider-row { display: flex; align-items: center; gap: 12px; }
    .slider-label { width: 80px; text-align: right; font-size: 11px; color: color-mix(in oklch, var(--fg), transparent 55%); flex-shrink: 0; user-select: none; transition: color 0.4s; }
    .slider-track {
      position: relative; flex: 1; display: flex; align-items: center;
      height: 44px; cursor: pointer; touch-action: none;
    }
    .slider-bg { position: absolute; left: 0; right: 0; height: 2px; top: 50%; transform: translateY(-50%); background: color-mix(in oklch, var(--fg), transparent 92%); border-radius: 9999px; transition: background 0.4s; }
    .slider-fill { position: absolute; left: 0; height: 2px; top: 50%; transform: translateY(-50%); background: color-mix(in oklch, var(--accent), transparent 50%); border-radius: 9999px; }
    .slider-thumb {
      position: absolute; width: 14px; height: 14px; top: 50%; transform: translate(-50%, -50%);
      background: color-mix(in oklch, var(--accent), transparent 15%);
      border-radius: 50%;
      box-shadow: 0 0 8px color-mix(in oklch, var(--accent), transparent 60%);
    }
    .slider-val { width: 32px; text-align: left; font-size: 11px; color: color-mix(in oklch, var(--fg), transparent 70%); flex-shrink: 0; user-select: none; font-variant-numeric: tabular-nums; transition: color 0.4s; }
    .bg-toggle {
      padding: 4px 14px; border-radius: 9999px; font-family: inherit; font-size: 11px;
      cursor: pointer; user-select: none; min-height: 28px;
      background: color-mix(in oklch, var(--fg), transparent 95%);
      color: color-mix(in oklch, var(--fg), transparent 55%);
      border: 1px solid color-mix(in oklch, var(--fg), transparent 90%);
      transition: background 0.4s, color 0.4s, border-color 0.4s;
    }
    .bg-toggle:hover { background: color-mix(in oklch, var(--fg), transparent 90%); }
    #last-updated { position: fixed; bottom: 12px; left: 12px; z-index: 10; font-size: 10px; color: color-mix(in oklch, var(--fg), transparent 80%); font-family: inherit; pointer-events: none; user-select: none; transition: color 0.4s; }
  </style>
</head>
<body>
  <canvas id="c" aria-label="Animated asterism generative art" role="img"></canvas>
  <div id="last-updated"></div>

  <div id="controls-wrap">
    <button id="toggle-btn">Controls</button>
    <div id="panel"></div>
  </div>

  <script>
  // ==========================================================================
  //  TAXONOMY
  //
  //  Dot  — the smallest element; a single tiny circle drawn on the canvas.
  //  Star — a cluster of dots arranged in concentric sub-rings.
  //  Ring — a large circular arrangement of stars around the center.
  //
  //  Visual hierarchy (outside → in):  Ring  →  Star  →  Dot
  // ==========================================================================

  // --- Layout constants ---

  // -- Star internals: each star is a cluster of dots in concentric sub-rings --
  const DOTS_PER_SUBRING = [3, 9, 14, 20, 28];           // dots in each sub-ring (innermost first)
  const SUBRING_OFFSETS = [0.75, 0.25, 0.75, 0.125, 0.5]; // rotational offset per sub-ring

  const DOT_SUBRING_SPACING = 8;   // px gap between concentric sub-rings of dots within a star
  const DOT_RADIUS = 8;            // drawn radius of each dot
  const DOT_INNER_OFFSET = 1;      // radial offset for the innermost sub-ring

  // -- Ring layout: stars are arranged in concentric rings around the center --
  const MAX_RINGS = 10;            // maximum rings the slider can reach
  const DEFAULT_RINGS = 4;         // default ring count on load
  const STAR_SPACING = 100;        // px gap between stars along a ring

  // How many stars sit in each ring (grows with circumference)
  const STARS_PER_RING = [3, 9, 14, 20, 28, 37, 47, 58, 70, 83];
  // Rotational offset per ring to avoid a gridded look
  const RING_OFFSETS = [0.75, 0.25, 0.75, 0.125, 0.5, 0.375, 0.625, 0.875, 0.1875, 0.5625];

  // Derived totals (allocated for MAX_RINGS so the buffers never need to grow)
  const DOTS_PER_STAR = DOTS_PER_SUBRING.reduce((a, b) => a + b, 0); // 74
  const MAX_TOTAL_STARS = STARS_PER_RING.reduce((a, b) => a + b, 0); // 369
  const BUF_SIZE = MAX_TOTAL_STARS + 10;

  const ANIM_FRAMES = 180;
  const TWO_PI = Math.PI * 2;

  // --- Utility functions ---

  // Seeded PRNG (mulberry32) — deterministic randomness so the pattern is stable
  function mulberry32(seed) {
    return function () {
      let t = (seed += 0x6d2b79f5);
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
  function mapVal(v, a1, b1, a2, b2) { return a2 + (b2 - a2) * ((v - a1) / (b1 - a1)); }
  function normVal(v, a, b) { return (v - a) / (b - a); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  // --- Parameters (controlled by sliders) ---
  // rings: 0..1 maps to 1..MAX_RINGS (default → 4)
  const LCH_DARK  = { lightness: 0.61, chroma: 0.91, hue: 28/360 };
  const LCH_LIGHT = { lightness: 0.38, chroma: 0.83, hue: 78/360 };
  const systemLight = window.matchMedia('(prefers-color-scheme: light)').matches;
  const params = { arcMin: 0, arcMax: 0, decay: 0, speed: 0.3, density: 0.5, spread: 0.52, rings: 7/9, ...(systemLight ? LCH_LIGHT : LCH_DARK), light: systemLight };
  const sliderUpdaters = {}; // keyed by param name, set during slider setup

  // --- Animation state ---
  // Pre-computed random values, seeded so every load looks the same.
  const rng = mulberry32(42);
  const ringRand = new Float32Array(MAX_RINGS);            // one random value per ring (shared by all stars in a ring)
  const starRand = new Float32Array(BUF_SIZE);             // one random value per star
  const totalDotSlots = BUF_SIZE * DOTS_PER_STAR;
  const dotRand = new Float32Array(totalDotSlots);         // one random value per dot
  const dotBrightness = new Float32Array(totalDotSlots);   // retained brightness per dot (for decay trails)
  for (let i = 0; i < MAX_RINGS; i++) ringRand[i] = rng();
  for (let i = 0; i < BUF_SIZE; i++) starRand[i] = rng();
  for (let i = 0; i < totalDotSlots; i++) dotRand[i] = rng();
  let time = 0;

  // --- Canvas setup ---
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth, h = window.innerHeight;
    const s = w < 600 ? 1.5 : 1;
    const cw = w * s, ch = h * s;
    canvas.width = cw * dpr;
    canvas.height = ch * dpr;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  // --- Draw a single star (cluster of dots) ---
  // effectiveArc: 0..1 fraction of each sub-ring arc that's visible (computed per-star by radial wave)
  function drawStar(x, y, starIndex, progress, scale, p, effectiveArc) {
    const arcFrac = effectiveArc;                         // fraction of each sub-ring arc that's visible
    const threshScale = mapVal(p.density, 0, 1, 6, 0);   // wave activation threshold (lower = more dots)
    const decaySpeed = mapVal(p.decay, 0, 1, 0.2, 15);   // how fast dots fade out

    // Sine wave drives dot activation across the star's cycle
    const wave = normVal(Math.sin(progress * TWO_PI), -1, 1);
    const baseThresh = mapVal(wave, 0, 1, 0, threshScale + starRand[starIndex % starRand.length] * 2);

    const subringGap = DOT_SUBRING_SPACING * scale;
    const innerOffset = DOT_INNER_OFFSET * scale;
    const dotHalfR = (DOT_RADIUS * scale) / 2;

    // Walk through each sub-ring of dots within this star
    let di = starIndex * DOTS_PER_STAR; // dot index into the flat random/brightness arrays
    for (let sri = 0; sri < DOTS_PER_SUBRING.length; sri++) {
      const dotsInSubring = DOTS_PER_SUBRING[sri];
      if (di + dotsInSubring > dotRand.length) break;

      // Each sub-ring has its own wave frequency and phase offset
      const freq = Math.floor(Math.max(dotRand[di] * 4 - 2, 0)) + 1;
      const localOffset = (progress * freq + Math.abs(dotRand[di] / 1.5)) % 1;
      // Weighting: inner sub-rings are brighter (ringWeight goes 1 → 0)
      const ringWeight = mapVal(sri, 0, DOTS_PER_SUBRING.length - 1, 1, 0);

      // Place each dot around the sub-ring
      for (let j = 0; j < dotsInSubring; j++) {
        const theta = (TWO_PI / dotsInSubring) * j + SUBRING_OFFSETS[sri] * TWO_PI;
        const rad = subringGap * (sri + 0.5) + innerOffset;
        const dotX = rad * Math.cos(theta) + x;
        const dotY = rad * Math.sin(theta) + y;

        // --- Arc culling: only draw dots within the visible arc ---
        const waveAngle = (localOffset * TWO_PI) % TWO_PI;
        const dotAngle = ((theta % TWO_PI) + TWO_PI) % TWO_PI;
        let angleDiff = Math.abs(dotAngle - waveAngle);
        if (angleDiff > Math.PI) angleDiff = TWO_PI - angleDiff;

        if (angleDiff > arcFrac * Math.PI) {
          // Outside the visible arc — just decay the dot's stored brightness
          dotBrightness[di] = clamp(dotBrightness[di] - decaySpeed, 0, 100);
          di++;
          continue;
        }

        // --- Dot activation (wave-based) ---
        const rp = normVal(Math.sin(theta + (localOffset + dotRand[di] * TWO_PI) * TWO_PI * 2), -1, 1);
        const amp = Math.abs(dotRand[di] * rp * rp);
        const brightness_wave = mapVal(Math.sin(theta + localOffset * TWO_PI), -1, 1, 0, 2 - dotRand[di] + ringWeight / 2) + amp;
        const vel = Math.cos(theta + localOffset * TWO_PI);

        let br = dotBrightness[di] || 0;
        if (brightness_wave > baseThresh && vel >= 0) {
          br = Math.ceil(100 - dotRand[di] * 10 + ringWeight * 20);
        } else if (brightness_wave > baseThresh && vel < 0) {
          br = Math.floor(100 + 20 * vel);
        } else {
          br = clamp(br - Math.ceil(decaySpeed / (ringWeight + 1)), 0, 50);
        }
        if (br < 0) br = 0;
        dotBrightness[di] = br;

        // --- Final brightness (quantized to steps of 10) ---
        const finalB = Math.floor(br / 10) * 10;

        // --- Draw the dot (oklch) ---
        if (finalB > 0.5) {
          const bN = finalB / 100;
          const bgL = p.light ? 0.970 : 0.194;
          const L = p.light ? bgL - bN * p.lightness : bgL + bN * p.lightness;
          const C = bN * p.chroma * 0.37;
          const H = p.hue * 360 + dotRand[di] * 40 + finalB * 0.25 - 32.5;
          ctx.fillStyle = `oklch(${L.toFixed(2)} ${C.toFixed(3)} ${H.toFixed(1)})`;
          ctx.beginPath();
          ctx.arc(dotX, dotY, dotHalfR, 0, TWO_PI);
          ctx.fill();
        }
        di++;
      }
    }

  }

  // --- Main animation loop ---
  let prevT = performance.now();
  function frame(now) {
    const dt = (now - prevT) / 1000;
    prevT = now;
    time += dt * mapVal(params.speed, 0, 1, 0.15, 3);

    const dpr = window.devicePixelRatio || 1;
    const w = canvas.width / dpr, h = canvas.height / dpr;
    const scale = Math.min(w, h) / 900;
    ctx.clearRect(0, 0, w, h);

    const cycleSec = ANIM_FRAMES / 60; // seconds per animation cycle at base speed
    const cycleProgress = (time / cycleSec) % 1;
    const cx = w / 2, cy = h / 2;

    // Current ring count from the slider (1..MAX_RINGS)
    const activeRings = Math.round(mapVal(params.rings, 0, 1, 1, MAX_RINGS));

    // Star spacing along each ring, affected by the "spread" slider
    const starGap = STAR_SPACING * scale * mapVal(params.spread, 0, 1, 0.4, 1.6);

    const maxRingRadius = starGap * (activeRings - 1 + 0.5) + starGap / 4;

    // Arc wave: a sine wave radiating outward from center, synced to animation cycle.
    // Each star's visible arc oscillates between arcMin and arcMax, with inner stars
    // leading and outer stars lagging — creating a breathing/pulsing radial effect.
    const arcWavePhase = time / cycleSec * TWO_PI;

    // Walk through each ring, then each star in that ring
    let starIndex = 0;
    for (let ri = 0; ri < activeRings; ri++) {
      const starsInRing = STARS_PER_RING[ri];
      for (let j = 0; j < starsInRing; j++) {
        // Place this star around the ring
        const theta = (TWO_PI / starsInRing) * j + RING_OFFSETS[ri] * TWO_PI;
        const ringRadius = starGap * (ri + 0.5) + starGap / 4;
        const starX = ringRadius * Math.cos(theta) + cx;
        const starY = ringRadius * Math.sin(theta) + cy;

        // Radial arc wave: stars closer to center lead, outer stars lag
        const distNorm = maxRingRadius > 0 ? ringRadius / maxRingRadius : 0;
        const arcWave = (Math.sin(arcWavePhase - distNorm * TWO_PI) + 1) / 2; // 0..1
        const effectiveArc = params.arcMin + (params.arcMax - params.arcMin) * arcWave;

        // All stars in a ring share the same random phase offset (ringRand),
        // so the wave front sweeps coherently around each ring (the "rotating" look).
        // Integer division on the ring term matches the original Processing sketch.
        const starProgress = (cycleProgress + normVal(theta, 0, TWO_PI) + ringRand[ri] + Math.floor((ri * 2) / activeRings)) % 1;

        drawStar(starX, starY, starIndex, starProgress, scale, params, effectiveArc);
        starIndex++;
      }
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // --- Controls UI ---
  function updateAccent() {
    const c = Math.max(params.chroma * 0.37, 0.05);
    document.documentElement.style.setProperty('--accent', `oklch(0.7 ${c.toFixed(3)} ${params.hue * 360})`);
  }

  const SLIDERS = [
    { key: 'rings',      label: 'Rings',        display: v => Math.round(mapVal(v, 0, 1, 1, MAX_RINGS)) },
    { key: 'arcMin',     label: 'Dot Arc Min' },
    { key: 'arcMax',     label: 'Dot Arc Max' },
    { key: 'decay',      label: 'Dot Decay' },
    { key: 'density',    label: 'Dot Density' },
    { key: 'speed',      label: 'Speed' },
    { key: 'spread',     label: 'Star Spread' },
    { key: 'lightness',  label: 'Lightness' },
    { key: 'chroma',     label: 'Chroma',      onChange: updateAccent },
    { key: 'hue',        label: 'Hue',         display: v => Math.round(v * 360), onChange: updateAccent },
  ];

  const panel = document.getElementById('panel');
  const toggleBtn = document.getElementById('toggle-btn');
  let panelOpen = false;

  toggleBtn.addEventListener('click', () => {
    panelOpen = !panelOpen;
    panel.classList.toggle('open', panelOpen);
    toggleBtn.textContent = panelOpen ? 'Hide' : 'Controls';
  });

  SLIDERS.forEach(({ key, label, display, onChange }) => {
    const row = document.createElement('div');
    row.className = 'slider-row';

    const lbl = document.createElement('span');
    lbl.className = 'slider-label';
    lbl.textContent = label;

    const track = document.createElement('div');
    track.className = 'slider-track';
    track.setAttribute('role', 'slider');
    track.setAttribute('aria-label', label);
    track.setAttribute('aria-valuemin', '0');
    track.setAttribute('aria-valuemax', '100');

    const bg = document.createElement('div');
    bg.className = 'slider-bg';
    const fill = document.createElement('div');
    fill.className = 'slider-fill';
    const thumb = document.createElement('div');
    thumb.className = 'slider-thumb';

    track.append(bg, fill, thumb);

    const valSpan = document.createElement('span');
    valSpan.className = 'slider-val';

    function updateVisual(v) {
      const pct = v * 100;
      fill.style.width = pct + '%';
      thumb.style.left = pct + '%';
      const displayVal = display ? display(v) : Math.round(pct);
      valSpan.textContent = displayVal;
      track.setAttribute('aria-valuenow', String(displayVal));
    }
    updateVisual(params[key]);
    sliderUpdaters[key] = updateVisual;

    let dragging = false;
    function setFromX(clientX) {
      const r = track.getBoundingClientRect();
      const v = Math.max(0, Math.min(1, (clientX - r.left) / r.width));
      params[key] = v;
      updateVisual(v);
      if (onChange) onChange();
    }

    track.addEventListener('pointerdown', (e) => {
      dragging = true;
      track.setPointerCapture(e.pointerId);
      setFromX(e.clientX);
    });
    track.addEventListener('pointermove', (e) => { if (dragging) setFromX(e.clientX); });
    track.addEventListener('pointerup', () => { dragging = false; });
    track.addEventListener('pointercancel', () => { dragging = false; });

    row.append(lbl, track, valSpan);
    panel.appendChild(row);
  });

  // --- Background toggle ---
  const bgRow = document.createElement('div');
  bgRow.className = 'slider-row';
  const bgLabel = document.createElement('span');
  bgLabel.className = 'slider-label';
  bgLabel.textContent = 'Background';
  const bgBtn = document.createElement('button');
  bgBtn.className = 'bg-toggle';
  bgBtn.textContent = params.light ? 'Light' : 'Dark';
  bgBtn.addEventListener('click', () => {
    params.light = !params.light;
    bgBtn.textContent = params.light ? 'Light' : 'Dark';
    const root = document.documentElement;
    root.style.setProperty('--bg', params.light ? 'oklch(0.970 0.003 106.449)' : 'oklch(0.194 0.006 55.987)');
    root.style.setProperty('--fg', params.light ? 'oklch(0 0 0)' : 'oklch(1 0 0)');
    document.querySelectorAll('meta[name="theme-color"]').forEach(m => m.content = params.light ? '#f7f6f2' : '#302a25');
    const preset = params.light ? LCH_LIGHT : LCH_DARK;
    for (const k in preset) {
      params[k] = preset[k];
      if (sliderUpdaters[k]) sliderUpdaters[k](params[k]);
    }
    updateAccent();
  });
  bgRow.append(bgLabel, bgBtn);
  panel.appendChild(bgRow);

  // --- Intro animation: ease arcMin & arcMax from 0 to target ---
  (function () {
    const targets = { arcMin: 0.10, arcMax: 0.95 };
    const duration = 2000; // ms
    const start = performance.now();
    function ease(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; } // easeInOutQuad
    function tick(now) {
      const t = Math.min((now - start) / duration, 1);
      const e = ease(t);
      for (const key in targets) {
        params[key] = targets[key] * e;
        if (sliderUpdaters[key]) sliderUpdaters[key](params[key]);
      }
      if (t < 1) requestAnimationFrame(tick);
      else oscillateArcMin();
    }
    requestAnimationFrame(tick);
  })();

  // --- Oscillate arcMin between 10 and 80 over 5s ---
  function oscillateArcMin() {
    const lo = 0.10, hi = 0.80;
    const mid = (lo + hi) / 2, amp = (hi - lo) / 2;
    const period = 10000;
    const origin = performance.now();
    function wave(now) {
      const v = mid - amp * Math.cos(TWO_PI * (now - origin) / period);
      params.arcMin = v;
      if (sliderUpdaters.arcMin) sliderUpdaters.arcMin(v);
      requestAnimationFrame(wave);
    }
    requestAnimationFrame(wave);
  }

  // --- Last updated (from GitHub API) ---
  fetch('https://api.github.com/repos/juliankellydesign/juliankellydesign.github.io/commits?per_page=1&sha=main')
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(([c]) => {
      const d = new Date(c.commit.committer.date);
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      document.getElementById('last-updated').textContent = 'Last updated ' + yyyy + '.' + mm + '.' + dd;
    })
    .catch(() => {});
  </script>
</body>
</html>
